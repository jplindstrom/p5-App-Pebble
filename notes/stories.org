
* STUFF DONE
* IDEAS
** Parallel processing
** Input
*** OS
**** ps
**** ls
**** find
**** iostat
**** du
**** df
**** /etc/passwd
**** git
***** log
*** Web
**** DONE GET
**** DONE XPaths
*** SQLite db
**** Is this a Parser or a Source?
*** SQL query
*** Data source dictionary in config
*** MySQL resultset output
**** Parse
***** with ;
***** with \G
** Source
*** Something + Parse
*** E.g.
**** S->Web->get($url)
**** S->DBI->db( $connect )->select( $sql )
** Render
*** DONE JSON
**** default
*** Pebble / Perl
*** Table (like SQL query)
*** HTML table
**** Possibly open browser
*** Org table
*** SQL
**** Insert
**** Update
**** Upsert
**** Use datatype to quote correctly
*** xargs
*** DONE CSV
*** SQLite db
** DONE Grep
** DONE Map
** Examples
*** Get a list of URLs, and find the Director, insert it into the director table
**** p -s --has=url urls.txt | p --grep '{ $url =~ /imdb.com/ }' | p html=Web-get(url) | p --with=html -parse=XPath --xpath=...
**** p -s --has=url urls.txt | p --grep url=/imdb.com/ | p --map '{ Web->get($url)' --parse=XPath --xpath=director='//
* STORIES
** DONE Move main to App::Pebble
** DONE Does the control ones need stringification?
*** no
*** 
** DONE plimit
** DONE Move onew, etc into Pebble::Object someting
*** Make it a plugin-like thing
** DONE Global cache manager, for e.g. caching http requests
*** can be reset for all, or for a type e.g. Web
** TODO ppool signature can be &;&&
** CLI
*** DONE Call with script file or source
*** allow it to be it's own script with .pbl extension
*** Call with parameters which are available inside
**** S->CLI->param( "name" );
** DONE differentiate between p and pmap
*** DONE Nope, instead use o { } to always return object
*** p always returns the object
*** pmap might be used to return a different type of object or string
** debug flag
** Log stuff
** Unify the R->, S-> etc
*** whether they're inside a p {} or not
*** Whether to take hash or hashref
** Unify Render / Renderer naming
** Plugin system for R, P, S
*** Syntax
**** S("XPath")->match()
**** P("Regex")->split()
**** R("Chart::Basic")->render(x => "date", y => "date")
*** 
** use Devel::Eval
*** http://search.cpan.org/~adamk/Devel-Eval-1.01/lib/Devel/Eval.pm
** Lexical vars for each attribute
** Lexical for $_ and pad
*** $o aliased to $_
*** $c is a context object that lives next to the stream, useful to keep track of stuff
** preverse
** psort
*** regular $a $b
** DONE osort
*** osort { "1-method_name" }
** group by
*** ogroup { -by => "q", -count => "count" }'
**** by scalar or array ref
**** use statistics module
**** Collect into arrayref, like GROUP_CONCAT, except not concat
*** ogroup_count { q => "q_count" }
**** Common special case
** Custom application calls
*** { S->Ion->search( -env="Live", q => $_->q ) }
** Load extra plugins from load path PEBBLE_LIB, or PERL5LIB or -I
** collect_pool
*** pool, but collects all the items and pass the whole lot to a single post sub
*** In IO::Pipeline
** Nicer error reporting
*** Missing |
Not enough arguments for App::Pebble::plimit at (eval 221) line 4, near "plimit |"
	...propagated at lib/App/Pebble.pm line 42.
*** Referring to attribute taht doesn't exist
Can't locate object method "episode" via package "Class::MOP::Class::__ANON__::SERIAL::20" at /home/lindsj05/Personal/Dev/CPAN/App-Pebble/source/lib/App/Pebble.pm line 223.
   ...propagated at /home/lindsj05/Personal/Dev/CPAN/App-Pebble/source/lib/App/Pebble.pm line 155.
** p --cmd=df 'R->Graph->basic( x => "mounted_on", y => "capacity" );
** p -m --match --has=abc,def,ghi or named captures
*** Not really needed, use P->match( regex => qr//, has => \qw( abc def ) )
** p -s --split '\t' --has=abc,def,ghi or ghi+ (means capture all the rest in there)
** p -p 'hello %s $name %20s, your birthday is {$birthdate->ymd}\n' title,lastname
** p -j --json
** p --in=CSV
*** Loads Pebble::In::CSV
**** Might load field defs from first line
**** p --in=CSV FILEs
*** p --in=CSV --csv_fields=abc,def,ghi
**** May select only those if already defined
**** implies --has=fields
**** May name them, in order to use them
***** --csv_fields=,,name,age,,title
****** To skip the first two and 5th csv column
** p --parse=
** p --table=
